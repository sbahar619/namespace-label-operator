name: Pull Request Validation

on:
  pull_request:
    branches: [ main, develop ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
      - 'LICENSE'
  workflow_dispatch:  # Allow manual triggering

env:
  GO_VERSION: '1.21'
  GOLANGCI_LINT_VERSION: 'latest'

jobs:
  # Job 1: Code Quality and Formatting
  code-quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Download dependencies
      run: go mod download

    - name: Verify go mod tidy
      run: |
        go mod tidy
        git diff --exit-code go.mod go.sum

    - name: Run go fmt
      run: |
        if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
          echo "The following files are not formatted:"
          gofmt -s -l .
          echo "Please run 'make fmt' to fix formatting issues."
          exit 1
        fi

    - name: Run go vet
      run: make vet

    - name: Run golangci-lint
      uses: golangci/golangci-lint-action@v6
      with:
        version: ${{ env.GOLANGCI_LINT_VERSION }}
        args: --timeout=5m

  # Job 2: Unit Tests with Coverage
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Download dependencies
      run: go mod download

    - name: Install test dependencies
      run: make envtest ginkgo

    - name: Run unit tests with coverage
      run: |
        make test
        go tool cover -html=cover.out -o coverage.html

    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./cover.out
        flags: unittests
        name: codecov-umbrella

    - name: Upload coverage artifact
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: coverage.html

    - name: Check coverage threshold
      run: |
        COVERAGE=$(go tool cover -func=cover.out | grep total | awk '{print $3}' | sed 's/%//')
        echo "Current coverage: ${COVERAGE}%"
        if (( $(echo "${COVERAGE} < 80" | bc -l) )); then
          echo "❌ Coverage ${COVERAGE}% is below threshold of 80%"
          exit 1
        fi
        echo "✅ Coverage ${COVERAGE}% meets threshold"

  # Job 3: End-to-End Tests
  e2e-tests:
    name: E2E Tests
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Create kind cluster
      uses: helm/kind-action@v1.8.0
      with:
        cluster_name: namespacelabel-e2e
        kubectl_version: v1.28.0

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Download dependencies
      run: go mod download

    - name: Install test dependencies
      run: make ginkgo

    - name: Build Docker images
      run: |
        make controller-docker-build
        make webhook-docker-build

    - name: Load images into kind cluster
      run: |
        kind load docker-image controller:latest --name namespacelabel-e2e
        kind load docker-image webhook:latest --name namespacelabel-e2e

    - name: Deploy to cluster
      run: |
        
        # Deploy controller and webhook with correct image references
        make deploy CONTROLLER_IMG=controller:latest WEBHOOK_IMG=webhook:latest

        # Patch manager container in controller deployment
        kubectl patch deployment namespacelabel-controller-manager -n namespacelabel-system --type=json --patch '[
          {
            "op": "replace",
            "path": "/spec/template/spec/containers/0/imagePullPolicy",
            "value": "IfNotPresent"
          }
        ]'

        # Patch webhook container in webhook deployment
        kubectl patch deployment namespacelabel-webhook-server -n namespacelabel-system --type=json --patch '[
          {
            "op": "replace",
            "path": "/spec/template/spec/containers/0/imagePullPolicy",
            "value": "IfNotPresent"
          }
        ]'
        
        # Wait for deployments to be ready
        kubectl wait --for=condition=Available deployment/namespacelabel-controller-manager -n namespacelabel-system --timeout=300s
        kubectl wait --for=condition=Available deployment/namespacelabel-webhook -n namespacelabel-system --timeout=300s
        
        # Verify deployment status
        kubectl get pods -n namespacelabel-system
        kubectl describe deployment namespacelabel-controller-manager -n namespacelabel-system
        kubectl describe deployment namespacelabel-webhook -n namespacelabel-system

    - name: Run E2E tests
      run: make test-e2e
      timeout-minutes: 20

    - name: Get pod logs on failure
      if: failure()
      run: |
        kubectl logs deployment/namespacelabel-controller-manager -n namespacelabel-system --tail=100
        kubectl get pods -n namespacelabel-system -o wide
        kubectl describe pods -n namespacelabel-system
        kubectl logs deployment/namespacelabel-webhook -n namespacelabel-system --tail=100

    - name: Cleanup kind cluster
      if: always()
      run: kind delete cluster --name namespacelabel-e2e

  # Job 4: Build Validation
  build:
    name: Build Validation
    runs-on: ubuntu-latest
    strategy:
      matrix:
        target: [controller, webhook]
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Download dependencies
      run: go mod download

    - name: Build binary
      run: make build

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build Docker image
      run: make ${{ matrix.target }}-docker-build

  # Summary job that all others depend on
  pr-validation-summary:
    name: PR Validation Summary
    runs-on: ubuntu-latest
    needs: 
      - code-quality
      - unit-tests
      - e2e-tests
      - build
    if: always()
    steps:
    - name: Check all jobs status
      run: |
        if [ "${{ needs.code-quality.result }}" != "success" ] || \
           [ "${{ needs.unit-tests.result }}" != "success" ] || \
           [ "${{ needs.e2e-tests.result }}" != "success" ] || \
           [ "${{ needs.build.result }}" != "success" ]; then
          echo "❌ One or more validation jobs failed"
          exit 1
        fi
        echo "✅ All validation jobs passed successfully!"